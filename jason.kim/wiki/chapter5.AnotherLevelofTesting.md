# Chapter5. Another Level of Testing
유닛 테스트는 TDD의 한가지 방법이다. 이외에 클래스간 상호작용 하는 부분도 테스트해야한다. 이 장에서는 통합 테스트와 BDD에 대해 다룬다.

## Integeration testing

통합 테스트 중에 소프트웨어 모듈의 개별 구성 요소가 함께 테스트 된다. 이 단계는 단위 테스트와 승인 테스트(acceptance testing) 사이에 있다. 단위 테스트는 클래스와 메소드 여부에 관계없이 단일 코드 단위를 테스트한다. 개별 요쇼가 사양에 따라 작동하는지 확인한 후에는 통합 테스트로 시작하여 모듈 / 구성 요소가 내부 및 외부의 다른 구성 요소와 예상대로 동작하는지 확인할 수 있다.

통합 테스트 프로세스는 다음 단계로 나눌 수 있다.

1. 상호 작용에 사용되는 유닛 간의 인터페이스를 식별
2. 완전한 엔드-투-엔드 통합을 구성하는 인터페이스가 있는 유닛 모음을 지정
3. 입력 및 예상 출력과 함께 통합 테스트 사례를 생성
4. 테스트를 평가하여 결과가 일치하는지 판별하고 결과를 기록

## Functional testing

기능 테스트는 검증 활동으로 생각할 수 있다. 블랙 박스 테스트의 한 유형이다. 기능 테스트의 테스트 사례는 테스트중인 소프트웨어 시스템의 기능 요구 사항을 기반으로 한다. 기능 테스트는 소프트웨어 시스템이 설계 사양에 따라 작동하는지 확인하는 최종 목표를 가지고 있다.
기능 테스트가 블랙 박스 테스트라고 하면 입력을 제공하고 출력을 예상 출력과 비교하여 소프트웨어가 기능적으로 테스트됨을 의미한다. 이것은 우리가 응용 프로그램의 기능 (방법)을 테스트하고 있음을 의미하지는 않는다. 기능의 일부를 테스트하고 있음을 의미한다.

기능 테스트와 관련된 단계 :

1. 테스트 할 기능을 식별
2. 테스트 데이터를 작성
3. 예상 출력을 확인
4. 테스트 케이스를 실행
5. 결과와 예상 결과를 비교
6. 결과를 한 부씩 인쇄

## Acceptance testing

승인 테스트는 최종 고객에게 더 중점을 둔다. 이는 고객의 관점에서 애플리케이션이 테스트 되었음을 의미한다. 경우에 따라 고객이이 테스트에 참여하고 테스트는 실제 프로덕션 시스템과 가능한 한 실제와 같은 환경에서 수행된다.
승인 테스트 동안 각 사용자 요구 사항은 객관성, 구현, 오류 처리 및 사용자 요구에 특정한 기타 세부 사항에 중점을 둔 테스트 사례를 사용하여 테스트된다.

### 유저 승인 테스트의 필요성

애플리케이션이 단위, 통합 및 기능 테스트를 거쳤음에도 불구하고 고객의 애플리케이션 관점과 개발자 또는 QA의 동일한 애플리케이션 관점 사이에는 항상 차이가있을 수 있다.
개발자가 테스트를 작성할 때 요구 사항에 대한 자체 이해를 고려합니다. 고객이 요청한 것과 동일하거나 동일하지 않을 수 있다. 이것은 의사 소통이 잘못되었거나 고객과 개발자 사이에 공용어가 부족한 결과 일 수도 있다.
요구사항이 진화하며 자주 발생하는 변화는 효과적으로 전달되지 않았을 수 있다. 응용 프로그램이 프로덕션 환경에 들어가기 전에 이러한 불일치를 확인하는 것이 좋다.
다음은 사용자 승인 테스트 단계이다.

1. 비즈니스 요구 사항을 분석
2. UAT 테스트 계획을 작성
3. 테스트 시나리오를 식별
4. UAT 테스트 사례를 생성
5. 테스트 데이터 (프로덕션과 유사한 데이터)를 준비
6. 테스트 케이스를 실행
7. 결과를 기록

## Behavior-driven development

행동 중심 개발 (BDD)은 현대 소프트웨어 산업 사전의 새로운 유행어이다. 테스팅 기술의 정수이다. 이것이 과대 광고에 맞설 지 여부는 아직 보이지 않지만 개발 과정에서 제품의 전반적인 성공에 있어 몇 가지 중요한 개선이 있었다.

### Introduction

소프트웨어 프로젝트의 거의 절반이 어떤 방식 으로든 전달하지 못하는 것으로 추정된다. 
BDD의 필요성은 이러한 문제에서 비롯된다. BDD는 가장 중요한 일에 큰 노력을 집중 시키려고 노력한다. 최대 비즈니스 가치를 유지하는 기능을 객관적으로보고 가장 비용 효율적인 방식으로 제공하는 것을 목표로 한다.
BDD는 개발 프로세스의 대안이 아니지만이 장에서 알 수 있듯이 BDD는 이러한 프로세스를 기반으로보다 나은 프로세스를 구축한다.

### 세 아미고 (Three amigos)

BDD의 핵심은 고객, 개발자 및 테스터가 처음부터 끝까지 참여하는 것 이다. 사실, 그들 중 세 명이 함께 앉아서 모든면에서 이해할 수있는 공통 언어 (유비쿼터스 언어)를 정의한다. 그 이후부터 모든 요구 사항이이 언어로 번역되고 개발은이 번역 된 기능에 의해 설정된 전제에서 시작된다.
이 모델을 종종 "세 아미고"또는 "세 세력(power of three)" 라고 한다. 이 맥락에서 3 개는 고객 (또는 고객의 대리자로 앉아있는 비즈니스 분석가), 개발자 및 QA를 나타냅니다. 이 세 가지 모두 서로 다른 종류의 전문 지식과 관점을 제공한다. 고객은 비즈니스 지식과 기능이 무엇을 원하는지에 대한 명확한 아이디어를 제공한다. 개발자는 기술 전문 지식을 도입하여 고객의 기대와 전체 응용 프로그램 설계를 조정하여 고객이 "약속의 땅"을 믿지 않도록하고 개발자가 불가능한 솔루션을 개발하도록 요청하지 않게 만든다. QA는 고객의 요구 사항과 개발자의 기술 사양을 쉽게 테스트하고 확인할 수있는 형식으로 만드는 데 도움이 된다.



### BDD의 조감도

일반적인 개발 프로세스의 예를 살펴보고 BDD가 어디에 적용되는지 확인하자. Phil의 회사는 법률의 일부 변경으로 인해 현재 급여 시스템에 새로운 기능이 추가되기를 원한다고 가정하자. 프로세스는 다음과 같이 진행된다
1. Phil은 비즈니스 분석가에게 기능의 작동 방식을 알려준다.
2. 비즈니스 분석가는 Phil의 요구 사항을 개발자를위한 기술 사례 또는 사양으로 변환한다.
3. 개발자는 이러한 기술 요구 사항을 Scala 코드로 작성하고 단위 테스트를 작성하여 그의 코드가 튼튼한지 확인한다.
4. QA는 요구 사항을 테스트 케이스로 변환하고 개발자가 작성한 코드가 이러한 테스트 케이스를 충족하는지 확이한다.
5. 기술 작성자는 응용 프로그램 코드를 설명서로 변환한다.

이 프로세스에는 정보를 잃을 수있는 많은 부분이 있다.

모든 사람이 스스로 작업하고 자신의 번역을 어느 정도 수행하기 때문에 모든 시점에서 잘못 해석하거나 과도하게 엔지니어링 할 가능성이 있다. Phil의 회사가 BDD를 사용하고 있다고 가정 하고 이 과정이 어떻게 진행되는지 살펴 보자.

1. Phil은 BA와 이야기하면서 자신이 만들어야 할 것을 말한다. 오해를 제거하기 위해 기능의 특정 예가 제공된다.
2. 개발이 시작되기 전에 세 가지 amigo (Dev, QA 및 BA)가 모여 이러한 요구 사항을 시나리오로 변환한다. 시나리오는 Phil, BA, Dev 및 QA가 모두가 이해할 수있는 것으로 동의 한 언어로 작성된다. 이 시점에서 Phil과 지속적으로 의사 소통을하여 기능을 이해하는 데 어려움을 겪는다. 유비쿼터스 언어는 "Gherkin" 이라고도 한다.
3. 개발자는 이러한 시나리오를 일련의 자동화 테스트로 전환한다. 이 테스트는 기능의 경계와 요구 사항을 표시하며 기능이 완료되었는지 확인하는 데 사용할 수 있다.
4. QA는 시나리오 및 자동화 테스트를 테스트 사례 작성의 시작점으로 사용한다.
5. 개발자는 모든 자동화 테스트가 통과되도록 응용 프로그램 코드를 작성한다.
6. 자동화 테스트 및 시나리오는 시스템의 저수준 문서화 역할 도 한다. 시스템 작동 방법에 대한 좋은 예를 제공 할 수 있다.

BDD 프로세스가 더 협업적임을 알 수 있다. 모든 사람이 요구 사항을 모든 수준에서 이해할 수 있는 보다 영어 같은 언어로 번역하기 위해 함께 노력한다. 모든 요구 사항에 대해 모두 같은 페이지에 있다. 이러한 요구 사항은 또한 제품을 과도하게 엔지니어링 할 위험을 최소화하며 시나리오 중심의 자동화 테스트에서 설정 한 경계에 따라 개발 노력이 제한된다. 유비쿼터스 언어로 작성된 이러한 시나리오는 문서 역할을 하며 제품과 함께 많은 문서가 필요하지 않다. Phil도 프로세스에 참여하고 있으며 언제든지 시나리오를 읽고 자신을 위해 무엇을 빌드하고 있는지 확인할 수 있다. 어느 시점에서든 동의하지 않을 경우, 성능이 저하되고 사용할 수 없는 시스템이 구축되기를 기다리는 대신 돈을 낭비하지 않고 즉각적인 변경을 요청할 수 있다.

### Gherkin

시장에 나와있는 거의 모든 BDD 도구는 영어와 같은 형식을 사용하여 요구 사항을 정의하고 자동 수락 테스트를 수행한다. 이 형식은 비즈니스, 개발자, 비즈니스 분석가 및 QA와 같은 모든 이해 관계자가 쉽게 이해할 수 있도록 설계되었다. 이 형식을 "거킨"이라고 한다. 엄밀히 말하면 Gherkin은 Cucumber BDD 도구 제품군에서 사용하는 형식을 나타내지만 Gherkin이 주도하는 JBehave 승인 테스트를 작성하는 것이 가능해졋다.



Cucumber는 다양한 플랫폼을 지원하는 BDD 프레임웍이다. Cucumber에서는 애플리케이션 코드를 설명하는 매우 높은 수준의 사양을 작성하여 통합 테스트를 작성할 수 있다. 이러한 고급 사양은 일반 텍스트로 되어 있다. Cucumber에 대한 자세한 내용은 https://cucumber.io/를 참고하라.

JBehave는 BDD의 또 다른 인기 프레임웍이다. 그리고 이름에서 알 수 있듯이 Java 및 관련 언어 (예 : 스칼라)와 더 밀접하게 연관되어 있다.. JBEhave에 대한 자세한 정보는 http://jbehave.org/를 참고하라.



Gherkin에서 기본 요구 사항은 동일한 기능(feature)이 기능 파일이라는 동일한 파일에 함께 있어야 한다. 이 기능 파일에는 기능에 대한 간단한 설명과 모든 시나리오 목록이 포함되어 있다. 이러한 시나리오는 기능의 작동 방식과 각 기능에 대해 의도 된 동작이 무엇인지에 대한 문서이다.
Gherkin을 사용하여 2 장, 첫 번째 테스트 기반 응용 프로그램 및 3 장, ScalaTest를 사용하여 코드 정리로 작성된 예제 응용 프로그램에 대한 시나리오를 작성했다. 다음은 Gherkin에서 기능을 작성 하기 위한 템플릿으로 사용할 수있는 매우 일반적인 형식이다.

```
기능 : 원하는 내용에 대한 간결하지만 설명이 포함 된 텍스트
	In order to 정의 된 비즈니스 가치를 실현
	As an explicit system 행위자
	I want to 목표를 발전시키는 유익한 결과

​	시나리오 : 일부 결정 가능한 비즈니스 상황 일부 전제 조건이 주어짐
​		Govem 몇몇 전제 조건
​			And 다른 전제 조건
​		When 액터에 의한 몇몇 행위
​			And 다른 행위
​		Then 몇 가지 테스트 가능한 결과의 달성
​		    And 그외 우리가 체크해야할 상황들

​	시나리오 : 다른 상황 ...
```

예시

```
기능: 급여 생성
	In order to determine the correct remuneration for an employee 
	As an explicit system HR manager
	I want to generate correct payroll for the employee
	
	Scenario: When employee has some unpaid holidays 
		Given an employee Jairus
			And Jairus has taken 10 days unpaid leaves 
    When HR manager generates his payroll
			And payroll is generated for the month of February 2016
    Then a correct payroll is generated
    	And the salary has deductions for the unpaid holidays
    	
	Scenario: When employee has no holidays ...

```

피처 파일은 일반적으로 .feature 확장자로 저장된다. 마지막 예제에서 작은 Gherkin 요구 사항이 일반 영어로 제공되지만 특정 구조가 있음을 알 수 있다. 모든 시나리오는 여러 단계로 구성된다. 각 단계는 키워드 중 하나 (Given, When, Then, And 및 But)로 시작합니다.

Given : 주어진 시나리오의 전제 조건을 정의. 테스트 환경을 준비하거나 데이터를 준비하는 데 사용
When : 행위자가 취한 행동을 설명
Then : 예상 결과 또는 동작을 설명

Gherkin을 사용하면 여러 상관 시나리오를 입력 테이블에 의해 구동되는 단일 시나리오로 모을 수 있다. 이것을 시나리오 개요라고 한다. 예를 들면 다음과 같다.

```
Scenario Outline: Calculate sum
Given I have two numbers <number-one> and <number-two> When these numbers are added
Then I should have the correct total <sum>
Examples:
| number-one | number-two | sum
| 10000 | 20000 | 30000
| 10000 | 40000 | 50000
```



### Executable specification

Gherkin으로 작성된 이러한 기능은 단계 정의를 통해 실행 가능한 실행 사양을 생성한다. 단계 정의는 단계 뒤에서 실행되는 코드다. 보다 성숙한 테스트 하니스에서는 단계 정의가 충분하기 때문에 단계 정의를 작성할 필요가 거의 없다. 따라서 동일하거나 유사한 언어가 사용되는 한 기능 사양의 대부분의 단계를 다룹니다.
이 실행 사양은 인수 테스트, 통합 테스트 또는 단위 테스트 중에 작성된 테스트 사례보다 자연 언어에 더 가깝다. 따라서 응용 프로그램 코드를 어떻게 사용해야하는지 예를들 수 있다. 또한 요구 사항에 대한 종합적인 이해에 대한 문서다.

### Don't repeat yourself

BDD를 사용할 때 스펙 레벨과 단위 레벨 모두에서 동일한 테스트를 반복하는 경우가 있다. 단위 수준에서 얼마나 테스트해야하는지, 사양 수준에서 얼마나 테스트 해야 하는지에 대한 다른 두가지 관점이 있다.

그 중 하나는 최소한의 단위 테스트를하면서 가능한 한 많은 사양을 문서화 해야 한다는 생각이다. 이 개발자 그룹은 모든 또는 대부분의 테스트가 비즈니스와 통신 할 수있는 방식으로 문서화 되어야 한다고 생각한다. 이것은 역 사다리꼴로 시각화 할 수 있다.

또 다른 하나는 BDD 사양에 합격 기준 만 있고 광범위한 단위 테스트 범위를 가지고 있다고 생각한다. 이 개발자 그룹은 테스트가 가능한 한 실제 코드에 최대한 가깝게 타겟팅 되어야 한다고 생각한다. 이것은 사다리꼴로 생각할 수 있다.

이 두 가지 접근 방식 모두 장단점이 있으며 잘못도 아니다. 중간 지점을 찾는 것은 독자의 몫 이다.. 나는 더 많은 단위 테스트와 적절한 수의 사양을 가지고있어 응용 프로그램 코드의 모든 기능이 문서화 되도록 하는걸 선호한다. 이유는 단위 테스트를 실행하는 데 필요한 인프라 코드가 적지 만 시나리오를 실행하려면 초기화해야 할 고정 장치가 적지 않기 때문이다.
스칼라 테스트를 통해 인터리브 단계 정의를 구성하는 방식으로 단위 테스트를 작성할 수 있다. BDD 스타일로 단위 테스트를 작성하는 열렬한 BDD 십자군이 이것을 사용할 수 있다.

BDD를 어떻게 사용해야하는지에 대한 두 가지 다른 생각이 있다. 한가지(BDD 십자군)는 BDD 시나리오를 수행하기 위해 응용 프로그램 코드를 작성해야하며, 결국 단위 테스트에 도달해야한다고 생각한다. 즉, BDD 시나리오를 작성하고 시나리오를 이행하기 위해 최소한의 애플리케이션 코드를 작성한다. 그런 다음이 시나리오를 충족시키기 위해 더 많은 시나리오를 추가하고 더 많은 애플리케이션 코드를 작성한다. 단위 테스트는 필요할 때마다 채워지지만 BDD는 TDD와 같은 방식으로 Red-Green-Refactor로 수행된다. 이 접근 방식을 사용하면 언제든지 녹색 테스트를 수행 할 때 단위 테스트와 BDD 시나리오가 모두 통과한다. 리팩토링은 모든 수준에서 가능한 한 무자비하게 수행된다.

다른 생각(TDD 숭배자)은 BDD 시나리오를 작성한 후에 응용 프로그램을 내부에 작성해야한다고 믿는다. 즉, TDD를 사용하여 응용 프로그램 코드를 작성한 다음 최종 목표가되도록 응용 프로그램을 작성해야 한다. BDD 시나리오가 이행된다는 것을 이 방법에서는 단위 테스트를 통과 할 수 있지만 TDD가 여전히 진행 중이므로 BDD 시나리오는 계속 통과하지 않는다.

나는 전통 주의자이며 두 번째 접근 방식과 비슷하지만 첫 번째 접근 방식이 비교 가능하다는 것이 쉽게 논쟁의 여지가 있다. 따라서 개발 방식에 적합한 접근 방식을 결정하는 것은 독자에게 맡겨져 있다. 둘 중 하나를 시도하고 어느 것이 더 적합한지를 결정하거나 어떤 경우에는 어떤 접근 방식이 다른 방법보다 더 잘 작동하는지 결정하는 것이 문제 일 수 있다.













